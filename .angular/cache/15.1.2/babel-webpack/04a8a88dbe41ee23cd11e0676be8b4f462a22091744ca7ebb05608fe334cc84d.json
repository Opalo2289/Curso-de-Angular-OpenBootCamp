{"ast":null,"code":"import { Observable } from 'rxjs';\nimport { CONTACTOS } from '../mocks/contactos.mock';\nimport * as i0 from \"@angular/core\";\nexport class ContactoService {\n  constructor() {}\n  /*\r\n  *Lo primero es crear un metodo. y va a ser accesible para los que tengan injectada la instancia ContactoService.\r\n  *para este ejemplo se crea en la carpeta models una lista de datos inventados y desde alli se exporta.\r\n  *Importamos la lista de contactos MOCKS ↑.\r\n  *Devolver el conjunto de datos\r\n  */\n  //AQUI VA EJEMPLO RETIRADO #2\n  /*\r\n  *Se trabajará aqui con una promesa (que debe devolver una promesa, no los DATOS de CONTACTOS especificamente)\r\n  */\n  obtenerContactos() {\n    return Promise.resolve(CONTACTOS); //hay que señalar el tipo de promesa y lo que esperamos que nos devuelva\n  }\n  /*Otro metodo o funcionalidad puede ser:\r\n  *Buscar el contacto por ID dentro de la lista de CONTACTOS mockeados\r\n    1. creas la variable const y buscas con find\r\n  */\n  //AQUI VA EJEMPLO RETIRADO #4\n  //EJEMPLO RETIRADO #5\n  /*\r\n  *Este metodo lo tomaremos para trabajar con un observable.\r\n  Los observables son metodos que van emitiendo nuevos valores cada ves, osea pueden emitir mas de un valor.\r\n  1- crear el observable\r\n  2. en el componente que este usando este metodo debemos susctribirnos en este caso en lista-contactos.component.ts\r\n  */\n  obtenerContactoPorID(id) {\n    const contacto = CONTACTOS.find(contacto => contacto.id === id); //(contacto.id === id) es decir: en caso de que contacto.id conincida con id que recibimos por parametro entonces lo devolvemos\n    //aqui creamos el observable.\n    let observable = new Observable(observer => {\n      observer.next(contacto); //aqui Emitimos un valor a todo componente que este suscrito a este observable\n      observer.complete(); //cuando se completa no emitimos mas valores\n    });\n\n    if (contacto) {\n      return observable; //aqui tenemos que especificar el tipo osea esto ↑ (Observable<IContacto>)\n    } else {\n      return;\n    }\n  }\n}\nContactoService.ɵfac = function ContactoService_Factory(t) {\n  return new (t || ContactoService)();\n};\nContactoService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: ContactoService,\n  factory: ContactoService.ɵfac,\n  providedIn: 'root' //esto quiere decir que es a nivel de raiz, osea que todos los componentes lo pueden utilizar\n});","map":{"version":3,"mappings":"AAUA,SAAqBA,UAAU,QAAQ,MAAM;AAE7C,SAASC,SAAS,QAAQ,yBAAyB;;AAMnD,OAAM,MAAOC,eAAe;EAE1BC,eAAgB;EAEhB;;;;;;EAOA;EAEA;;;EAGAC,gBAAgB;IACd,OAAOC,OAAO,CAACC,OAAO,CAACL,SAAS,CAAC,CAAC,CAAC;EACrC;EAKA;;;;EAKA;EAEA;EACF;;;;;;EAOEM,oBAAoB,CAACC,EAAU;IAE7B,MAAMC,QAAQ,GAAGR,SAAS,CAACS,IAAI,CAAED,QAAmB,IAAKA,QAAQ,CAACD,EAAE,KAAKA,EAAE,CAAC,EAAC;IAG7E;IACA,IAAIG,UAAU,GAA0B,IAAIX,UAAU,CAACY,QAAQ,IAAG;MAChEA,QAAQ,CAACC,IAAI,CAACJ,QAAQ,CAAC,EAAC;MACxBG,QAAQ,CAACE,QAAQ,EAAE,EAAC;IACtB,CAAC,CAAC;;IACF,IAAGL,QAAQ,EAAE;MACX,OAAOE,UAAU,CAAC,CAAC;KACpB,MAAK;MACJ;;EAEJ;;AArDWT,eAAe;mBAAfA,eAAe;AAAA;AAAfA,eAAe;SAAfA,eAAe;EAAAa,SAAfb,eAAe;EAAAc,YAFd,MAAM,CAAC","names":["Observable","CONTACTOS","ContactoService","constructor","obtenerContactos","Promise","resolve","obtenerContactoPorID","id","contacto","find","observable","observer","next","complete","factory","providedIn"],"sourceRoot":"","sources":["C:\\Users\\Guedys\\Documents\\ANGULAR-TYPESCRIPT\\OpenBootCamp\\Angular-OpenBootCamp\\HolaMundo\\src\\app\\services\\contacto.service.ts"],"sourcesContent":["/*\n*¿vamos a representar informacion que es independiente de la plantilla osea que no tiene que ver solo para un componente?\nR: por ejemplo, una lista de contactos se puede representar en la vista en formato lista o tabla pero el conjunto de datos es el mismo.\n   de esta manera esa iformacion va a ser compartida para los diferentes componentes. aqui es momento de sacar la logica hacer un servicio e injectarlo como dependencia\n\n* ¿necesitamos que la app represente la info de diferentes maneras?\nR: tener en cuenta la persistencia de la informacion, esto tiene que ver con el estado de la app, es informacion que queremos mantener siempre disponible.\n*/\n\nimport { Injectable } from '@angular/core';\nimport { observable, Observable } from 'rxjs';\n\nimport { CONTACTOS } from '../mocks/contactos.mock';\nimport { IContacto } from '../models/contacto.interfase';\n\n@Injectable({\n  providedIn: 'root' //esto quiere decir que es a nivel de raiz, osea que todos los componentes lo pueden utilizar\n})\nexport class ContactoService {\n\n  constructor() { }\n\n  /*\n  *Lo primero es crear un metodo. y va a ser accesible para los que tengan injectada la instancia ContactoService.\n  *para este ejemplo se crea en la carpeta models una lista de datos inventados y desde alli se exporta.\n  *Importamos la lista de contactos MOCKS ↑.\n  *Devolver el conjunto de datos\n  */\n\n  //AQUI VA EJEMPLO RETIRADO #2\n\n  /*\n  *Se trabajará aqui con una promesa (que debe devolver una promesa, no los DATOS de CONTACTOS especificamente)\n  */\n  obtenerContactos(): Promise <IContacto[]> {\n    return Promise.resolve(CONTACTOS); //hay que señalar el tipo de promesa y lo que esperamos que nos devuelva\n  }\n\n\n\n\n  /*Otro metodo o funcionalidad puede ser:\n  *Buscar el contacto por ID dentro de la lista de CONTACTOS mockeados\n    1. creas la variable const y buscas con find\n  */\n\n  //AQUI VA EJEMPLO RETIRADO #4\n\n  //EJEMPLO RETIRADO #5\n/*\n*Este metodo lo tomaremos para trabajar con un observable.\nLos observables son metodos que van emitiendo nuevos valores cada ves, osea pueden emitir mas de un valor.\n1- crear el observable\n2. en el componente que este usando este metodo debemos susctribirnos en este caso en lista-contactos.component.ts\n*/\n\n  obtenerContactoPorID(id: number): Observable<IContacto> | undefined {\n\n    const contacto = CONTACTOS.find((contacto: IContacto) => contacto.id === id) //(contacto.id === id) es decir: en caso de que contacto.id conincida con id que recibimos por parametro entonces lo devolvemos\n\n\n    //aqui creamos el observable.\n    let observable: Observable<IContacto> = new Observable(observer => { \n      observer.next(contacto) //aqui Emitimos un valor a todo componente que este suscrito a este observable\n      observer.complete() //cuando se completa no emitimos mas valores\n    })\n    if(contacto) {\n      return observable; //aqui tenemos que especificar el tipo osea esto ↑ (Observable<IContacto>)\n    }else {\n      return;\n    }\n  }\n}\n\n/*Realizado estos metodos lo que viene es injectar este servicio a cualquier conponente\n  en este caso se injecta a app-lista-contactos\n*/\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}